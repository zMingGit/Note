# 文件历史缓存到数据库的功能规范

由于 Seafile 中文件历史是需要由 commit 历史实时计算出来的，这在资料库历史很长，commit 数量很多的时候会导致计算单个文件历史时间很长。有时会导致网页返回超时错误。

由于把所有文件的历史都缓存到数据库中会导致数据库非常大，所以目前考虑把 Office 文件（.doc, .docx, .ppt, .pptx, .xls, .xlsx）的修改历史缓存下来。将来可以把需要缓存的文件类型做成可配置。

## 配置

```
[FILE HISTORY]
enable = true
suffix=doc,docx,ppt,pptx,xls,xlsx
```

## 数据库表

文件历史数据库缓存表由 seafevents 来负责创建和维护，表中包含以下列：

- `repo_id`：
- `path`：需要对 `repo_id` 和 `path` 建联合索引
- `commit_id`：对应文件版本所在的 commit id
- `ctime`：版本的创建时间，也就是 commit 创建的时间
- `file_id`：该版本的文件 id
- `file_size`：该版本的大小
- `renamed_old_path`：如果该版本由重命名或者移动操作产生，则记录操作前的文件路径
- `creator`: 文件变更的执行者.

索引

- index(repo_id, path) seahub查询的时候使用  
- index(repo_id, ctime) seafevent恢复以前的历史数据的时候使用

## 缓存的维护

文件历史缓存由 seafevent 来负责更新。seafevents 在收到 seaf-server 发送的 RepoUpdateEvent 之后，对该事件对应的 commit 执行 diff 算法，找到所有被更新的文件。如果被更新的文件里面包含需要缓存历史的文件类型，则把该文件版本的信息记录到缓存表中。

diff 结果中需要进行文件历史缓存记录处理的文件：

- 新建文件
- 新建一个目录：需要扫描这个目录下面的所有文件
- 更新文件
- 重命名文件
- 重命名文件夹
- 移动文件
- 移动文件夹

seafevent 将每次commit的结果作为一个‘任务’，把这个任务放在队列中，然后一个工作线程去处理。

如果 Seafile 系统已经运行了一段时间，那么对于那些原来的文件历史，提供了一个单独的命令去运行恢复之前的文件历史的代码。

`代码设计`: 一次从 Seafile 中获得一个资料库，然后查找这个资料库在数据库中是否存在记录，如果存在，则找到ctime最小的commit，然后获得这个commit之前的所有commit，依次添加到任务队列中。

其中如果是删除的文件夹或者文件，如果是事实运行的时候，就会直接删除，如果是脚本添加的，则会添加一条 commit_id 和 file_id 改为  `ddddddddddddddddddddddddddddd` 的记录，然后在这一个资料库历史恢复完毕之后统一找到，并删除。

## 调用

Seahub 中会调用seafevent的接口查看对于文件历史处理是否要依赖于seafevent，如果依赖的话，则调用 Seafevent 中的接口，否则调用 Seafile 的接口. 以及返回给前端的变量名称统一了一下.


Seahub 查询一个文件的历史，如果是依赖 Seafevent 接口以后，则并不是以文件为对象，而是以当前的资料库和当前查询文件的路径为对象去查询。如果是依赖 Seafile接口， 则以文件为对象.