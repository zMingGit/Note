## 需求
使用分布式来解决索引实时化的问题以及索引任务分配。

## 记时
N/N

## 流程

![SeafEvents Redis](https://dev.seafile.com/seahub/lib/663d57b8-1602-4d6c-a8e3-1b237ca3a766/file/%E6%90%9C%E7%B4%A2%E3%80%81%E4%BA%8B%E4%BB%B6%E7%AD%89%E6%9C%8D%E5%8A%A1/seafes%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2/Seafevents-Redis.png?raw=1)

## 设计

### 架构

* 采用一个事件队列发布节点， 一个事件处理master节点，以及数个事件处理节点的架构。
* seafevents作为事件队列的发布节点。
* 会将一台机器的seafes作为master节点启动，订阅事件队列，以及分发任务。
* 其余的seafes节点会自动去请求master节点分发的任务，并处理。

### 发布和订阅

* 当seafevents发布消息的时候，如果没有任何节点订阅这个channel[名称:repo-update]，则会把这期间发送的事件记录在日志中，以便日后排查.
* redis的消息发布，必须先要有人订阅，所以seafes的master节点需要先启动，否则订阅之前发布的消息只能接收到一条。

### work thread 任务竞争
    redis:setnx 设置一个key value，如果key存在，则啥都不做，返回0，如果不存在，则设置，返回1

    1. 当拿到一个repo_id的时候，用repo_id作为key，用当前时间加上超时时间（一天）+1 为value
    2. 如果设置成功，则更新资料库
    3. 如果设置不成功, 则获得这个value查看，如果value已经过期则删除锁并执行步骤1

    tip: 时间都会转为标准utc时间然后操作

### REDIS库

* 使用redis内部的retry_on_timeout，当超时时，会自动重试一次，以保证是redis服务的问题。
* redis自带连接词，每次执行命令的时候会去尝试从连接池里获得一个连接，所以只需要初始化的时候以连接池的形式初始化就可以了
* 当redis初始化完成的时候，会发送一个ping请求，如果失败，会记录在日志中。



## 配置与执行

### seafevent节点

#### 配置
`conf/events.conf`:

```
[EVENTS PUBLISH]
enabled = true
mq_type = redis

[REDIS]
server = x.x.x.x
port = xx
password = xxxx
```

#### 运行
`./seafile.sh start`会自动创建seafevent进程

### Index Master节点

#### 配置

`conf/index-master.conf`:

```
[DEFAULT]
mq_type=redis

[REDIS]
server = x.x.x.x
port = xx
password = xxxx
```

#### 运行


在`seafile-server-last`目录下执行`./run_index_master.sh`

### Index Slave节点

#### 配置

`conf/index-slave.conf`

```
[DEFAULT]
mq_type = redis
index_works = 2 # Index worker thread count

[REDIS]
server = x.x.x.x
port = xx
password = xxxx
```

#### 执行

在`seafile-server-last`目录下执行`./run_index_worker.py`